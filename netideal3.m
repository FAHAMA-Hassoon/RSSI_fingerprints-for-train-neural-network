function [Y,Xf,Af] = netideal3(X,~,~)
%NETIDEAL3 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Dec-2021 19:45:11.
% 
% [Y] = netideal3(X,~,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 3xQ matrix, input #1 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 2xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-89.18967768;-70.09852964;-80.67348047];
x1_step1.gain = [0.0752671118185085;0.0775355839673851;0.0897217961374416];
x1_step1.ymin = -1;

% Layer 1
b1 = [1.1499658765569960028;0.99970234198307550422;-0.667671942883116043;-2.1398152284990432648;2.0347831076796940586;0.96414677760004063867];
IW1_1 = [-0.82472918161448871555 -0.15050118851805205367 1.4366719860263956754;-0.84905837783649629191 1.1483173258200107814 -0.05542328643725167453;1.2442897239668981868 0.28057057671039692393 -0.4223616735674219913;-0.29707465884363254416 -2.0786951287183708104 -0.023860282678266106493;2.764818673746625155 -1.6051809841811162105 -0.49438041893421275086;-0.28961166672379146103 -0.091133475627002274999 1.0295397086221329541];

% Layer 2
b2 = [0.055424925821684067895;0.47072681351195722055];
LW2_1 = [-1.5592829598678716874 1.2227150201356942194 -0.41505617947556366909 -1.2054746812819647772 -0.033135389047903487936 -1.4935318061619344832;1.0233990196418680796 -1.4364117280078048111 -0.77315620412352048518 0.12669315670587599776 0.30614846548421043027 -2.0431981761035964418];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.416666666666667;0.277777777777778];
y1_step1.xoffset = [0.45;0.45];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
